#include <iostream>
#include <fstream>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <string>
#include "egm.pb.h" // generated by Google protoc.exe
#include <cstring> // gives the additional functionality to work with strings and chars
static int portNumber = 6510;
static unsigned int sequenceNumber = 0; //message number, use it to check for lost messages
//char robotLogName[13] = "RobotLog.txt";
//char sensorLogName[14] = "SensorLog.txt";
double degrees = 0;

using namespace std;
using namespace abb::egm;



void CreateSensorMessage(EgmSensor* pSensorMessage){ // receives a pointer to the EgmSensor data structure (see the egm.proto file or ABB Application Manual EGM) 

	// message Header in egm.proto file 
	EgmHeader* pHeader = new EgmHeader; 
	pHeader->set_mtype(EgmHeader_MessageType_MSGTYPE_CORRECTION); 
    pHeader->set_seqno(sequenceNumber++); // encreases for each message server sends
    pHeader->set_tm(GetTickCount());// timestamp, e.g. for monitoring delays
	// provides Header to the SensorMessage data structre
	pSensorMessage->set_allocated_header(pHeader); 
	// reference degrees for the joints 
	EgmJoints *pJoints = new EgmJoints();
	degrees += 0.1;
	if (degrees <=45){
		pJoints->add_joints(degrees);
		pJoints->add_joints(0);
		pJoints->add_joints(0);
		pJoints->add_joints(0);
		pJoints->add_joints(90);
		pJoints->add_joints(-90);
	}else{
		degrees = 45;
	}

	/*
	for (int i =1; i<6; i++){
		pJoints->set_joints(i,0); // repeated field is like dynamically sized array <set_joints(index, value)>
	}
	*/
	
	//Setting reference degrees for the <planned> field of EGMSensor data structure;
	EgmPlanned *pPlanned = new EgmPlanned();
	pPlanned->set_allocated_joints(pJoints);
	pSensorMessage->set_allocated_planned(pPlanned);
}
 

void DisplayRobotMessage(EgmRobot *pRobotMessage){ // receives a pointer to the RobotMessage data structure in egm.proto
    /*Any information from a robot you want to output in the console 
	can be specified here*/
	if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype())
    {
        printf("SeqNo=%d Tm=%u Type=%d\n", pRobotMessage->header().seqno(), pRobotMessage->header().tm(), pRobotMessage->header().mtype());
    }
    else
    {
        printf("No header\n");
    }
	
}

void WriteRobotLogFile (EgmRobot *pRobotMessage, ofstream &robotLog){
	if (pRobotMessage->has_header() && pRobotMessage->header().has_seqno() && pRobotMessage->header().has_tm() && pRobotMessage->header().has_mtype())
	    {
		    robotLog << pRobotMessage->header().seqno()<<"\t"<< pRobotMessage->header().tm()<<"\tfeedt"/*<<pRobotMessage ->feedback().joints().joints(0)<<"\t"*/
		    		<< pRobotMessage ->feedback().time().usec()<<"\tconv"<<pRobotMessage->mciconvergencemet()<<"\tplant"/*<< pRobotMessage ->planned().joints().joints(0)<<"\t"*/
					<<pRobotMessage ->planned().time().usec()<<"\tutil"<<pRobotMessage->utilizationrate()<<"tmots"<<pRobotMessage->motorstate().state()<<"\tmcs"
					<<pRobotMessage->mcistate().state()<<"\texecs"<<pRobotMessage->rapidexecstate().state()<<endl;

		    //<<pRobotMessage ->feedback().joints()
		    //<<pRobotMessage ->planned().joints()
		    //<<pRobotMessage ->feedback().time()
		    //<<pRobotMessage ->planned().time()
		    //<<pRobotMessage->motorstate().state()
		    //<<pRobotMessage->mcistate().state()
		    //<<pRobotMessage->rapidexecstate().state()
	    }
	    else
	    {
	    	robotLog << "No header" << endl;

	    }


}
void WriteSensorLogFile(EgmSensor *pSensorMessage, ofstream &sensorLog){
	if (pSensorMessage->has_header() && pSensorMessage->header().has_seqno() && pSensorMessage->header().has_tm() && pSensorMessage->header().has_mtype())
	    {
		   sensorLog << pSensorMessage->header().seqno() <<"\t"<< pSensorMessage->header().tm()<<"\tplant"/*<< pSensorMessage ->planned().joints().joints(0)<<"\t"*/
					<<pSensorMessage ->planned().time().usec()/*<<"\t"<<pSensorMessage->speedref().joints().joints(0)*/<<endl;
		   //<<pSensorMessage->planned().joints()
		   //<<pSensorMessage ->planned().time()
		   //<<pSensorMessage->speedref().joints()

	    }
	    else
	    {
	    	sensorLog << "No header" << endl;

	    }

}
/*
char* toChar(string filename){
	//filename.append(ext);
	int n = filename.length();
	char* filename_char = new char[n+1]; // do not forget to free up the memory later in the program
	strcpy(filename, filename.c_str());
	return filename;
}
*/

int main(int argc, char *argv[]) {
	/* Specifying the names for the Robot and the Sensor log files */
	/*
	char robotLogName[50], sensorLogName[50];
	cout << "Specify a name for the Robot log file: " << endl;
	cin >> robotLogName;
	cout << "Specify a name for the Sensor log file: " << endl;
	cin >> sensorLogName;
	*/
	string robotLogName, sensorLogName;
	cout << "Specify a name for the Robot log file: " << endl;
	getline(cin, robotLogName);
	cout << "Specify a name for the Sensor log file: " << endl;
	getline(cin, sensorLogName);
	//char* robotLogNametxt, sensorLogNametxt; // ostsream accepts only char type
	//sensorLogNametxt = addFileExtension(sensorLogName);
	//robotLogNametxt = addFileExtension(robotLogName); // add extension to a file
	sensorLogName += ".txt";
	robotLogName += ".txt";
	//add extension to a file
	/* Delete the log files if they happen to have the same names as it was specified above*/
	/*
	if( remove( "myfile.txt" ) != 0 )
     cerr << "Error deleting file\n" ;
  else
    cout( "File successfully deleted" );
   return 0;
   */

	remove(sensorLogName.c_str()); // c_str() converts string to *char
	remove(robotLogName.c_str());

	/*-------------------------------Socket--------------------------------*/
	/* Init winsock */
    WSADATA wsaData; // this structure contains information about the Windows Socket implementation
    if (WSAStartup(MAKEWORD(2,2), &wsaData) != 0) //  	initialize use of Winsock Dll
	    {
	        fprintf(stderr, "Could not open Windows connection.\n");
	        //exit(0);
			return 0;
	    }else{
		    cout << "The Winsok status: " << wsaData.szSystemStatus << endl;
		}

    /* create socket to listen on */
	SOCKET sockfd = INVALID_SOCKET;
    sockfd = ::socket(AF_INET,SOCK_DGRAM,0); // :: means looking for a global namespace
    if (sockfd == INVALID_SOCKET){
			cout << "Error at socket: "<< WSAGetLastError()<< endl;
			WSACleanup(); // stop using Windows Socket dll (resources clean up)
			return 0; // in case of an error main function returns int here (convention)
		}else{
			cout << "Socket is working!" << endl;
		}
	/* populating the attributes of the serverAddr which is the instance of sockaddr_in structure */
    struct sockaddr_in serverAddr, clientAddr;	// sockaddr_in structure holds the IP and the port number
    memset(&serverAddr, sizeof(serverAddr), 0);
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddr.sin_port = htons(portNumber);

    /* binding the IP address and the port number to the socket which are sockaddr structure's attributes */
    if (bind(sockfd, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR){ //(struct sockddr *) is type casting here
			cout << "socket bind failure: " << WSAGetLastError() << endl;
			closesocket(sockfd);
			WSACleanup();
			return 0;
		}else{
			cout << "Socket bind is successful!" << endl;
			//cout << "SevIp: Port:"<< endl; // print out IP and Port in the cmd
			/*
			char serverIP[12], serverPORT[5];
		    ZeroMemory(serverIP, 12);
		    ZeroMemory(serverPORT, 5);
		    inet_ntop(AF_INET, &serverAddr.sin_addr, serverIP, 12); // converting to standrard text format
			inet_ntop(AF_INET, &serverAddr.sin_port, serverPORT, 5);
			printf("Server's Ip: %s, Server's Port: %s\n  ", serverIP, serverPORT);

			char clientIP[12], clientPORT[5];
			inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, 12);
			inet_ntop(AF_INET, &clientAddr.sin_port, clientPORT, 5);
			printf("Client's Ip: %s, Client's Port: %s\n", clientIP, clientPORT);
			*/
			cout <<"Ready to receive messages from the Robot." << endl;
		}
	/*------------------------------Socket----------------------------*/

    string messageBuffer; // string as a container to send serialized data (our reference coordinates for a robot)
	char protoMessage[1400]; // array of chars as a container to receive serialized message from a robot
	int len = sizeof(clientAddr);
	int bytesReceived;
    int bytesSend;
    ofstream robotLog(robotLogName,ios::app); // output stream to write out robot messages
    ofstream sensorLog(sensorLogName, ios::app); // output stream to wrete out sensor messages
    //delete robotLogNametxt; // free up memory
   // delete sensorLogNametxt; //free up memory
    /*Filling in the headers of log files*/
    robotLog <<"MessageNumber" <<"\t"<<"Timestamp" << endl;
    sensorLog << "MessageNumber" <<"\t"<<"Timestamp" << endl;

    while(true)
    { // actual Externally Guidance Motion Control of a robot happens in this loop
		//receving serialized message from a robot
		bytesReceived = recvfrom(sockfd, protoMessage, 1400, 0, (struct sockaddr *)&clientAddr, &len);
		if (bytesReceived == SOCKET_ERROR)
        {
            cout<< "Could not receive datagram." << WSAGetLastError() << endl;
            continue;
        }
		//deserialize inbound (received) message
		EgmRobot *pRobotMessage = new EgmRobot(); // initializing a pointer to the EgmRobot data structure (see the egm.proto file or ABB Application Manual EGM)
		pRobotMessage->ParseFromArray(protoMessage, bytesReceived); // deserialization
        DisplayRobotMessage(pRobotMessage); // print out the robot message in the console 
        WriteRobotLogFile(pRobotMessage, robotLog); // writes data send by the robot to the file
        //EgmRapidCtrlExecState RapidState;
        //RapidState = pRobotMessage->rapidExecState();
		delete pRobotMessage; // free up resources
		
		// create and serialize a sensor message (our reference coordinates which we want the robot to move to)
		EgmSensor *pSensorMessage = new EgmSensor(); 
        CreateSensorMessage(pSensorMessage);
        WriteSensorLogFile(pSensorMessage, sensorLog);
        pSensorMessage->SerializeToString(&messageBuffer); // initializing a pointer to the EgmSensor data structure (see the egm.proto file or ABB Application Manual EGM)
		
		// send a message to the robot from our sensor (personal computer)
		bytesSend = sendto(sockfd, messageBuffer.c_str(), messageBuffer.length(), 0, (struct sockaddr *)&clientAddr, len);
        if (bytesSend == SOCKET_ERROR){
	        cout << "Error transmitting data: " << WSAGetLastError() << endl;
			cout << "Probably EGM module has stopped due to fulfilling convergence criterion for the last point of the trajectory" << endl;
			delete pSensorMessage;
			robotLog.close(); // closing output stream
			sensorLog.close();// closing output stream
			closesocket(sockfd); // close socket
	        WSACleanup(); // free up resources used by winsok
			return 0;
		}   	     
        delete pSensorMessage; // free up resources
		

    }
    //while (RapidState == RAPID_RUNNING);

   return 0 ;

}


